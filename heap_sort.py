"""
    堆排序
    
    树:
        树是一种数据结构
        树是一种可以递归定义的数据结构
        树是由n个节点组成的集合
            如果n=0，那么是一个空树
            如果n>0,存在一个节点作为树的根节点，其他节点可以分为m个集合，每个集合本身就是一棵树。
    树的基本概念:
        根节点:树的开始节点
        叶子节点:度为零的节点
        树的深度(高度):树中节点的最大层次
        树的度:树中最大节点的度
        孩子节点:一个节点含有的子树的根节点称为该节点的子节点，或者孩子节点
        父节点:若一个节点含有孩子节点，这节点称为该子节点的父节点
        子树:非叶子节点构成的树

    二叉树:
        度不超过二的数，每个节点最多分两个叉
        每个节点最多有两个孩纸节点
        两个孩子节点为区分为左孩子节点和右孩子节点
    满二叉树:
        如果一个二叉树，每一层的结点数都达到最大值，则这个二叉树就是满二叉树

    完全二叉树:
        叶子节点只能出现在最下层和次下层，并且最下面一层的节点都集中在该层最左边的若干位置的二叉树。
    堆就是一种特殊的完全二叉树

    二叉树的存储方式:
        链表
        顺序表:列表的方式存储
    
    父节点和孩子节点的下标有什么关系:
        父节点的编号是i
        左孩子节点的编号就是2i+1
        右孩子节点的编号就是2i+2
        子节点的编号是i
        父节点的编号就是(i - 1) // 2

    堆:
        是一种特殊的完全二叉树
    大根堆:
        一颗完全二叉树，满足任意一个节点都比其孩子节点大
    小根堆:
        一颗完全二叉树，满足任意一个节点都比其孩子节点小

    堆的向下调整性质:
        假设根节点的左右子树都是堆，但根节点不满足堆的性质
        可以通过一次向下调整来将其变成一个堆。
        当根节点的左右子树都是堆的时候，可以通过一次向下调整来使其变成一个堆  

    堆排序的过程
        1. 建立堆
        2. 得到堆顶元素，为最大元素
        3. 去掉堆顶，将堆最后一个元素放到堆顶，可以通过一次向下调整重新使得堆有序
        4. 堆顶元素为第二大元素
        5. 重复步骤3，直到堆变空
"""

from typing import List


def sift(li: List, low: int, high: int) -> None:
    """
        向下调整函数

        low:堆顶位置
        high:堆的最后一个元素的位置
    """
    
    # 得到堆顶元素的位置
    i = low
    
    # 左孩子节点的位置
    j = 2 * i + 1
    
    # 堆顶元素,让堆顶元素下来
    tmp = li[i]
    
    # j超过了high，表示i就是最后一层
    while j <= high:
        # 只要j位置有节点，就一直循环
        
        # 当右孩子存在并且右孩子比左孩子大，将j指向右孩子的位置
        if li[j + 1] > li[j] and j + 1 <= high:
            j = j + 1
        
        # j位置的更大,将j位置的元素放到堆顶，i往下看一层
        if li[j] > tmp:
            li[i] = li[j]
            i = j
            j = 2 * i + 1
        
        # tmp更大,把tmp放到i的位置上
        else:
            break
    
    # 将tmp放到正确的位置上，当j > high或者tmp位置的值更大，都需要将tmp放到正确的位置上
    li[i] = tmp


def heap_sort(li: List):
    """
        堆排序
    """
    
    n = len(li)
    for i in range((n - 1 - 1) // 2, -1, -1):
        # i表示建堆的时候调整部分的根的下标
        sift(li, i, n - 1)

    # 建堆完成
    for i in range(n - 1, -1, -1):

        # i指向当前堆的最后一个元素
        li[0], li[i] = li[i], li[0]
        
        # i - 1是新的high的位置
        sift(li, 0, i - 1)


li = [1, 5, 9, 2, 4, 6, 8, 7, 3]
heap_sort(li)
print(li)
